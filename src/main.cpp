// // STD Headers
// #include <iostream>
// #include <boost/dll/config.hpp>
// #include <boost/function.hpp>
// // Boost Headers
// #include <boost/dll/import.hpp> // for import_alias
// #include "./plugin.hpp"

// int main(int argc, char** argv)
// {

//     boost::dll::shared_library lib("boost-dll-playground_plugin", boost::dll::load_mode::append_decorations);

//     std::cout << "plugin->calculate(1.5, 1.5) call: " <<  boost::dll::import_alias<my_plugin_api>(boost::move(lib), "plugin")->calculate(1.5, 1.5) << std::endl;


//     // // boost::shared_ptr<std::string> pVar = boost::dll::import_symbol<std::string>( pathDLL, "sModuleName" );
//     // boost::shared_ptr<my_plugin_api> plugin = boost::dll::import_symbol<my_plugin_api>(         // type of imported symbol is located between `<` and `>`
//     // ,                     // path to the library and library name
//     // "",                                       // name of the symbol to import
//     //     boost::dll::load_mode::append_decorations              // makes `libmy_plugin_sum.so` or `my_plugin_sum.dll` from `my_plugin_sum`
//     // );



//     return 0;
// }

// Copyright 2014 Renato Tegon Forti, Antony Polukhin.
// Copyright Antony Polukhin, 2015-2022.
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt
// or copy at http://www.boost.org/LICENSE_1_0.txt)

#ifndef BOOST_DLL_EXAMPLE_COMMON_B2_WORKAROUNDS_HPP
#define BOOST_DLL_EXAMPLE_COMMON_B2_WORKAROUNDS_HPP

#include <boost/dll/config.hpp>
#include <boost/filesystem.hpp>
#include <boost/system/error_code.hpp>
#include <iostream>
#include <cctype>

namespace b2_workarounds {

inline boost::filesystem::path drop_version(const boost::filesystem::path& lhs) {
    boost::filesystem::path ext = lhs.filename().extension();
    if (ext.native().size() > 1 && std::isdigit(ext.string()[1])) {
        ext = lhs;
        ext.replace_extension().replace_extension().replace_extension();
        return ext;
    }

    return lhs;
}

inline bool is_shared_library(const std::string& s) {
    return (s.find(".dll") != std::string::npos || s.find(".so") != std::string::npos || s.find(".dylib") != std::string::npos)
            && s.find(".lib") == std::string::npos
            && s.find(".exp") == std::string::npos
            && s.find(".pdb") == std::string::npos
            && s.find(".manifest") == std::string::npos
            && s.find(".rsp") == std::string::npos
            && s.find(".obj") == std::string::npos
            && s.find(".a") == std::string::npos;
}

inline bool is_shared_library(const char* p) {
    return b2_workarounds::is_shared_library(std::string(p));
}

inline bool is_shared_library(const boost::filesystem::path& p) {
    return b2_workarounds::is_shared_library(p.string());
}

#ifdef BOOST_DLL_USE_STD_FS
inline bool is_shared_library(const std::filesystem::path& p) {
    return b2_workarounds::is_shared_library(p.string());
}
#endif

inline boost::dll::fs::path first_lib_from_argv(int argc, char* argv[]) {
    BOOST_ASSERT(argc > 1);
    (void)argc;

    for (int i = 1; i < argc; ++i) {
        if (b2_workarounds::is_shared_library(argv[i])) {
            return argv[i];
        }

        std::cout << "b2_workarounds::first_lib_from_argv(argc, argv): skipping '" << argv[i] << "'" << std::endl;
    }

    BOOST_ASSERT(false);
    return argv[1];
}

// This ugly struct is required to drop library version from shared library generated by b2.
struct argv_to_path_guard {
    const boost::filesystem::path original_;
    const boost::filesystem::path version_dropped_;
    const std::string just_path_;
    const bool same_;


    static inline boost::filesystem::path drop_b2_deco(const boost::filesystem::path& in) {
        std::size_t pos = in.filename().string().find("-");
        boost::filesystem::path res = in.parent_path() / in.filename().string().substr(0, in.filename().string().find("-"));
        if (pos != std::string::npos) {
            res += in.extension();
        }
        return res;
    }

    inline explicit argv_to_path_guard(int argc, char* argv[])
        : original_(first_lib_from_argv(argc, argv))
        , version_dropped_( drop_b2_deco(drop_version(original_)) )
        , just_path_( version_dropped_.parent_path().string() )
        , same_(version_dropped_ == original_)
    {
        if (!same_) {
            boost::system::error_code ignore;
            boost::filesystem::remove(version_dropped_, ignore);
            boost::filesystem::copy(original_, version_dropped_, ignore);
        }

        argv[1] = const_cast<char*>(just_path_.c_str());
    }

    inline ~argv_to_path_guard() {
        if (!same_) {
            boost::system::error_code ignore;
            boost::filesystem::remove(version_dropped_, ignore);
        }
    }
};

} // namespace b2_workarounds

#endif 

#include <boost/dll/import.hpp> // for import_alias
#include <boost/function.hpp>
#include <iostream>
#include "./plugin.hpp"

namespace dll = boost::dll;

int main(int argc, char* argv[]) {

    boost::dll::fs::path shared_library_path = "./libboost-dll-playground_plugin";
    typedef boost::shared_ptr<my_plugin_api> (pluginapi_create_t)();
    boost::function<pluginapi_create_t> creator;

    creator = boost::dll::import_alias<pluginapi_create_t>(             // type of imported symbol must be explicitly specified
        shared_library_path,                                            // path to library
        "create_plugin",                                                // symbol to import
        dll::load_mode::append_decorations                              // do append extensions and prefixes
    );

    boost::shared_ptr<my_plugin_api> plugin = creator();
    std::cout << "plugin->calculate(1.5, 1.5) call:  " << plugin->calculate(1.5, 1.5) << std::endl;
    std::cout << "plugin->calculate(1.5, 1.5) second call:  " << plugin->calculate(1.5, 1.5) << std::endl;
    std::cout << "Plugin Name:  " << plugin->name() << std::endl;
    std::cin.get();
    return 0;
}